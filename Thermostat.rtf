{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red217\green11\blue0;}
\margl1440\margr1440\vieww25320\viewh14600\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs36 \cf0 Thermostat\
\
----------------------------------------------------------------------------------------\
1/26/2016 - first version\
2/7/2016 - ?resuming with thermostat\
\
\
LEFT OFF: I created the test and need to finish the mockup classes\
\
\
----------------------------------------------------------------------------------------\
\
\
Goal:\
 - webpage to set temperature\
 - rules: warm up in morning\
 - record of external temp, internal temp, times of active heating\
\
----\
Version 1: Webpage to set temperature\
\
NEEDED:\
A. thermostat daemon - given a set temp, activate heat below threshold until above threshold\
B. control web page - post a temperature, which communicates with daemon process\
C. temperature monitor - interface with USB\
D. hardware - relays to heating system, breakout board of pi, power source\
\
---\
A. thermostat daemon\
\
a single python script\
endpoint on localhost:port\
	posts heater status to a localhost:port\
	reports set point \
	accepts new set point on localhost:port\
	reports current temperature, which it is reading from the thermometer component\
polls current temperature from some url or reads from database\
capable of POSTING heater status change to any url\
after 5 minutes below set point-1, turns on heater\
keeps heater on until set point+1\
doesn't cycle off heater for at least 5 minutes\
doesn't keep heater on for more than 20 minutes\
does turn heater on until it's been off for 20 minutes\
logging\
unit testing\
sqlite database of history by minute\
daemon infrastructure to ensure always running\
\
---\
B. control web page\
\
initially, this is just an HTML interface to the thermostat json endpoints\
	it doesn't have any internal state, persistence, or logic\
	eventually, this would display temperature grabs and analysis\
\
reports current set point, which it reads from thermostat endpoint\
reports heater status, which it reads from thermostat endpoint\
form to change set point, which it posts to thermostat endpoint\
DDNS to be accessible from outside house\
\
---\
C. temperature monitor\
\
python script, run as each minute cron job\
polls temperature from USB\
saves temperature to sqlite database every minute\
	including a 1-record last-query table\
\
---\
D. heater interface & hardware\
\
this will be written as a python module that can be used by other python programs\
it will have a script front end for testing with these options:\
	--turn_on\
	--turn_off\
	--status\
it may just save state as a file\
buy relays and wire on amazon\
for starters, only need a single relay for the heater (not AC)\
breakout board for raspberry pi\
	first test turning on a LED\
	then hook up to relay\
need to run extension cord down from attic and out existing hole\
setup pi & relays on hutch\
\
---\
A. thermostat daemon - test setup\
\
in order to facilitate testing, the thermostat instance needs to take the following objects\
	heater\
	thermometer\
	clock\
\
heater\
	the real heater instance will be the python module of component D\
	the test heater instance will have the same interface, but can be told what states it should expect to be in, and will throw an exception if it is told to change into an unexpected state\
\
thermometer\
	the real thermometer instance will read the current temperature from the sqlite database that component C is writing to\
	the test thermometer can be told to report any temperature\
\
clock\
	the real clock instance will report the current time and, at some interval, trigger the thermostat for a state decision\
	the test clock can be set to report any time and will manually trigger the thermostat for a state decision\
	this sounds unusual, but the unit tests need to be able to simulate the passing of time. For example, the test needs to be able to simulate the passing of 10 minutes after the end of a heating cycle\
\
tests:\
report and change heater status\
report thermometer reading\
accept and report set point\
after 5 minutes below set point-1, turns on heater\
keeps heater on until set point+1\
doesn't cycle off heater for at least 5 minutes\
doesn't keep heater on for more than 30 minutes\
	\cf2 How do thermostats handle this? If I leave the door wide open, will it cranks the heat for 16 hours? Or will it eventually time out and permanently shut down?\cf0 \
does turn heater on until it's been off for 20 minutes\
\
\
\

\f1\fs24 def setUpOnce():\
	random.seed(0)\
\
def setUp():\
	self.heater = new TestHeater()\
	self.thermometer = new TestThermometer()\
	self.clock = new TestClock()\
	self.thermostat = new Thermostat(self.heater, self.thermometer, self.clock)\
\
	# in the beginning, temperature is above threshold, heater is off, both exceptions are on\
	self.clock.set_clock(0)\
	self.thermometer.set_temperature(68)\
	self.thermostat.threshold_low(67) # turn on heater if 67 or below\
	self.thermostat.threshold_high(69) # turn off heater if 69 or above\
	self.heater.set_to_on(False)\
	self.heater.exception_if_turned_on(True)\
	self.heater.exception_if_turned_off(True)\
	self.thermostat.iterate()\
\
def test_read_heater_status():\
	self.heater.set_to_on(True)\
	self.assertTrue(self.thermostat.heater_is_on())\
	self.heater.set_to_on(False)\
	self.assertFalse(self.thermostat.heater_is_on())\
\
def test_turn_on_heater_manually():\
	# turn on heater\
	self.heater.set_to_on(False)\
	self.heater.exception_if_turned_on(False)\
	self.heater.exception_if_turned_off(True)\
	self.thermostat.set_heater_to_on(True)\
	self.assertTrue(self.heater.is_on())\
\
def test_turn_off_heater_manually():\
	# turn off heater\
	self.heater.exception_if_turned_on(True)\
	self.heater.exception_if_turned_off(False)\
	self.thermostat.set_heater_to_on(False)\
	self.assertFalse(self.heater.is_on())\
\
def test_read_thermometer():\
	for temp in [0, -5, 98.6]:\
		self.thermometer.set_temperature(temp)\
		self.assertEquals(self.thermostat.get_temperature(), temp)\
\
def test_set_point():\
	for temp = in [40, 68, 82]:\
		self.thermostat.set_target_temperature(temp)\
		self.assertEquals(self.thermostat.get_target_temperature(), temp)\
		self.assertLessThan(self.thermostat.threshold_low, temp)\
		self.assertGreaterThan(self.thermostat.threshold_high, temp)\
\
def test_set_point_too_low():\
	temp = 39 # min allowable is 40\
	with self.assertRaises(ThermostatException):\
		self.thermostat.set_target_temperature(temp)\
\
def test_set_point_too_high():\
	temp = 83 # max allowable is 82\
	with self.assertRaises(ThermostatException):\
		self.thermostat.set_target_temperature(temp)\
\
def test_turn_heater_on_when_too_cold():\
	# after 5 minutes below at of below .threshold_low(), turns on heater\
	# advance to some arbitrary time, go below threshold\
	self.clock.advance_random()\
	self.thermometer.set_temperature(67)\
	self.thermostat.iterate()\
	# advance less than the required time, heater still off\
	self.clock.advance(minutes=4.9)\
	self.thermostat.iterate()\
	# advance to the required time, heater should kick on\
	self.clock.advance(minutes=0.1)\
	self.heater.exception_if_turned_on(False)\
	self.thermostat.iterate()\
	self.assertTrue(self.heater.is_on())\
\
def helper_get_cold_to_trigger_heater():\
	# possible unintended consequences if not run as first line in test\
	# advance to some arbitrary time, it is now too cold\
	self.clock.advance_random()\
	self.thermometer.set_temperature(67)\
	self.thermostat.iterate()\
	# stay cold long enough for heater to kick on\
	self.clock.advance(minutes=5)\
	self.heater.exception_if_turned_on(False)\
	self.thermostat.iterate()\
	self.assertTrue(self.heater.is_on())\
\
def test_turn_heater_on_when_too_cold_helper():\
	self.helper_get_cold_to_trigger_heater():\
\
def test_dont_heat_up_if_not_cold_long_enough():\
	# threshold duration is 5 minutes. heater should not turn on if cold for 4, warm for 1, cold for 4\
	# advance to some arbitrary time, go below threshold\
	self.clock.advance_random()\
	self.thermometer.set_temperature(67)\
	self.thermostat.iterate()\
	# advance less than the required time, heater still off\
	self.clock.advance(minutes=4)\
	self.thermostat.iterate()\
	# advance 1 minute, but temperature is above threshold now\
	self.clock.advance(minutes=1)\
	self.thermometer.set_temperature(68)\
	self.thermostat.iterate()\
	# advance 1 minute, temperature back below threshold\
	self.clock.advance(minutes=1)\
	self.thermometer.set_temperature(67)\
	self.thermostat.iterate()\
	# advance less than the required time, heater still off\
	self.clock.advance(minutes=4)\
	self.thermostat.iterate()\
\
def test_keep_heater_on_until_warm_enough():\
	self.helper_get_cold_to_trigger_heater():\
	# advance arbitrary amount of time, heater is still on\
	# this arbitrary time must be less than the maximum-on-duration (20 minutes)\
	self.clock.advance(minutes=7.2)\
	self.thermostat.iterate()\
	# come above threshold, heater should turn off\
	# total arbitrary time must be less than the maximum-on-duration (20 minutes)\
	self.clock.advance(minutes=4.8)\
	self.thermometer.set_temperature(69)\
	self.heater.exception_if_turned_off(False)\
	self.thermostat.iterate()\
	self.assertFalse(self.heater.is_on())\
\
def test_dont_cycle_off_heater_too_quickly():\
	self.helper_get_cold_to_trigger_heater():\
	# advance 1 minute, already warm enough, but don't cycle off heater yet\
	self.clock.advance(minutes=1)\
	self.thermometer.set_temperature(69)\
	self.thermostat.iterate()\
	# advance to just under cycle minimum time on, heater should still be on\
	self.clock.advance(minutes=3.9)\
	self.thermostat.iterate()\
	# advance beyond cycle minimum time on, heater should turn off\
	self.clock.advance(minutes=0.1)\
	self.heater.exception_if_turned_off(False)\
	self.thermostat.iterate()\
	self.assertFalse(self.heater.is_on())\
\
def test_dont_cycle_on_heater_too_quickly():\
	# the beginning of this test needs to trigger the heater and let things warm up\
	self.helper_get_cold_to_trigger_heater():\
	# advance and warm up\
	self.clock.advance(minutes=10)\
	self.thermometer.set_temperature(69)\
	self.heater.exception_if_turned_off(False)\
	self.thermostat.iterate()\
	self.assertFalse(self.heater.is_on())\
	# the heater is off now, but throw exception if thermostat tries to turn if off again\
	self.heater.exception_if_turned_off(True)\
	# now quickly get cold again, but don't turn on heater yet\
	self.clock.advance(minutes=1)\
	self.thermometer.set_temperature(67)\
	self.thermostat.iterate()\
	# advance to just inside cycle limit, still not on yet\
	self.clock.advance(minutes=3.9)\
	self.thermostat.iterate()\
	# advance to just outside of cycle limit, heater should kick on\
	self.clock.advance(minutes=0.1)\
	self.heater.exception_if_turned_on(False)\
	self.thermostat.iterate()\
	self.assertTrue(self.heater.is_on())\
\
def test_dont_keep_heater_on_forever():\
	# maximum on for 30 minutes, even if not warm enough yet\
	self.helper_get_cold_to_trigger_heater():\
	# temperature is still too cool, advance to just before time limit\
	self.clock.advance(minutes=29)\
	self.thermostat.iterate()\
	# advance past limit, heater should go off even though still cold\
	self.clock.advance(minutes=1)\
	self.heater.exception_if_turned_off(False)\
	self.thermostat.iterate()\
	self.assertFalse(self.heater.is_on())\
\
\
\
\
\

\f0\fs36 -----------\
\
class HeaterControl(object):\
	"""Controls on/off of the heater and enforces cycle protection"""\
\
	def __init__(self, clock):\
		self._clock = clock\
		self._no_turn_on_before = None\
		self._no_turn_off_before = None\
		self._turn_on_time = None\
		self._turn_off_time = None\
		self._on_since = None\
		self._off_since = None\
		self._intended_on = False\
		self._actually_on = False\
		self.maximum_on_time = 1 hour?\
		self.minimum_on_time = 5 minutes\
		self.minimum_off_time = 5 minutes\
\
	def is_on(self):\
		"""Returns the intended state of the heater.\
\
		For example, the heater can be set to off, but it hasn't turned off yet\
		because the cycle protection won't allow it. This method will return\
		False, but is_heather_actually_on() will return True.\
		"""\
		return self._intended_on\
\
	def set_to_on(self, val):\
		"""Sets the intended state of the heater.\
\
		The change won't take effect immediately if the cycle protection\
		is in effect.\
\
		Note: This only sets the time-based fields to their appropriate values. The caller\
		has to continually call .iterate() in order for the changes to take effect.\
		"""\
		\
		# turning on\
		if val:\
			self._intended_on = True\
			# turning on and not currently on\
			if not self._actually_on:\
				self._turn_on_time = max(self.no_turn_on_before, self.clock.time())\
				self._turn_off_time = None\
		# turning off\
		else:\
			self._intended_on = False\
			# turning off and not currently off\
			if self._actually_on:\
				self.turn_on_time = None\
				self.turn_off_time = max(self.no_turn_off_before, self.clock.time())\
\
def iterate(self):\
	# if we passed the turn off time\
	if self._turn_off_time and self._turn_off_time < self.clock.time():\
		# if the time was set before the cycle protection, log message and push the time back\
		if self.no_turn_off_before and self.no_turn_off_before > self.turn_off_time:\
			self._logger.warn("Turn off time was set before cycle protection. Will not turn off until cycle protection is over.")\
			self.turn_off_time = self.no_turn_off_before\
\
		# otherwise turn off\
		self._actually_on = False\
		self._logger.info("Reached turn off time. Turning off.")\
		self.turn_off_time = None\
		self.turn_on_time = None\
		self._on_since = None\
		self._off_since = self.clock.time()\
		self.no_turn_off_before = None\
		self.no_turn_on_before = clock.time() + self.minimum_off_protection\
\
	# if we passed the turn on time\
	if self.turn_on_time and self.turn_on_time < self.clock.time():\
		# if this would turn on before the cycle protection, log message and push the time back\
		if self.no_turn_on_before and self.no_turn_on_before > self.turn_on_time:\
			self._logger.warn("Turn on time was set before cycle protection. Will not turn on until cycle protection is over.")\
			self.turn_on_time = self.no_turn_on_before\
\
		# otherwise turn on\
		self.heater.set_to_on(True)\
		self._logger.info("Reached turn on time. Turning on.")\
		self.turn_off_time = None\
		self.turn_on_time = None\
		self._on_since = None\
		self._off_since = self.clock.time()\
		self.no_turn_off_before = clock.time() + self.minimum_on_protection\
		self.no_turn_on_before = None\
\
	# if we passed the maximum on time\
	if self._on_since and (self.clock.time() - self._on_since) > self.maximum_on_time:\
		self._logger.warn("Reached maximum consecutive on time. Scheduling for shutdown.")\
		self.set_to_on(False)\
		self.iterate()\
\
\
\
----\
\
On - Turn on in 20 seconds. The 20 second delay is in case the user changes status again. Don't turn on before the cycle protection.\
	# it's fine if the heater is already running based on auto settings, this will be harmlessly redundant\
	# if self.no_turn_on_before is None, the other option is selected (i.e. not an exception)\
\
Off - Wait 20 seconds\
	# nearly the opposite of on mode\
\
Auto\
	if the heater is on\
		if the temperature is below low threshold, stay on\
		if the temperature is above low threshold, turn off as soon as possible\
	if the heater is off\
	 \
\
\
def check_thresholds(self):\
	# record threshold crossings\
	if self.threshold_low:\
		# if below low threshold\
		if self.thermometer.temperature < self.threshold_low:\
			if self.crossed_below_low_threshold_at is None:\
				self.crossed_below_low_threshold_at = self.clock.time()\
				self._logger.debug("Exceeded low threshold");\
		# if at or above low threshold\
		else:\
			if self.crossed_below_low_threshold_at is not None:\
				self.crossed_below_low_threshold_at = None\
				self._logger.debug("Within low threshold");\
	if self.threshold_high:\
		# if above high threshold\
		if self.thermometer.temperature > self.threshold_high:\
			if self.crossed_above_high_threshold_at is None:\
				self.crossed_above_high_threshold_at = self.clock.time()\
				self._logger.debug("Exceeded high threshold);\
		# if at or below high threshold\
		else:\
			if self.crossed_above_high_threshold_at is not None:\
				self.crossed_above_high_thresholdat = None\
				self._logger.debug("Within high threshold")\
\
def iterate(self):\
\
	self.check_thresholds()\
\
	# if we passed the turn off time\
	if self.turn_off_time and self.turn_off_time < self.clock.time():\
		# if the time was set before the cycle protection, log message and push the time back\
		if self.no_turn_off_before and self.no_turn_off_before > self.turn_off_time:\
			self._logger.warn("Turn off time was set before cycle protection. Will not turn off until cycle protection is over.")\
			self.turn_off_time = self.no_turn_off_before\
\
		# otherwise turn off\
		self.heater.set_to_on(False)\
		self._logger.info("Reached turn off time. Turning off.")\
		self.turn_off_time = None\
		self.turn_on_time = None\
		self.no_turn_off_before = None\
		self.no_turn_on_before = clock.time() + self.minimum_off_protection\
\
	# if we passed the turn on time\
	if self.turn_on_time and self.turn_on_time < self.clock.time():\
		# if this would turn on before the cycle protection, log message and push the time back\
		if self.no_turn_on_before and self.no_turn_on_before > self.turn_on_time:\
			self._logger.warn("Turn on time was set before cycle protection. Will not turn on until cycle protection is over.")\
			self.turn_on_time = self.no_turn_on_before\
\
		# otherwise turn on\
		self.heater.set_to_on(True)\
		self._logger.info("Reached turn on time. Turning on.")\
		self.turn_off_time = clock.time() + self.maximum_on_time\
		self.turn_on_time = None\
		self.no_turn_off_before = clock.time() + self.minimum_on_protection\
		self.no_turn_on_before = None\
\
\
\
}